\input{headers}


\begin{abstract}

Since its creation in 2009, Bitcoin has used a hash-based proof-of-work to
generate new blocks, and create a single public ledger of transactions. The
hash-based computational puzzle employed by Bitcoin is instrumental to its
security, preventing sybill attacks and making double-spending attacks more
difficult. However, there have been concerns over the efficiency of this
proof-of-work puzzle, and alternative ``useful'' proofs have been proposed.

In this paper, we present DDoSCoin, which is a cryptocurrency with a
\emph{mallicious} proof-of-work. DDoSCoin allows miners to prove that they have
contributed to a distributed denial of service attack against a specific target.
This proof involves making a large number of TLS connections to a target server,
and using infrequent cryptographic responses as a proof.



\end{abstract}




\section{Introduction}

Cryptocurrencies rely on proofs-of-work (PoW) that
require miners to spend a large amount of effort to solve a specific puzzle,
such that once solved, allowing others to inexpensively verify the solution is a
valid one. In Bitcoin, the proof-of-work is a computational puzzle based on the
SHA256 hash function, and miners are tasked with finding a partial preimage. The
only known way to do this is to iterate over a large number of inputs to the
hash function, and check if the output hash is less than a specified target. In
simplified terms, to find an input that hashes to N bits of 0s, the miner must
perform on average $2^{N}$ hashes. However, once found, other miners and Bitcoin
nodes can verify the puzzle solution with
a single hash~\footnote{Bitcoin uses double-SHA256 in its design, but this
detail is not important for the purposes of this paper.}.


Although the proof-of-work used in Bitcoin gives it resistance to sybil attacks,
the amount of computational effort carried out collectively by its miners does
not contribute to any problems besides securing the currency from attack.
Indeed, this computational effort is substantial: As of 2016, miners
collectively perform roughly $10^{18}$ (or about $2^{60}$) hashes every
second~\cite{blockchain}.

Previously, researchers have proposed alternative cryptocurrencies (altcoins)
that aim to have more beneficial proofs-of-work~\cite{primecoin,permacoin} that
provide utility beyond securing the underlying currency. In this paper however,
we investigate going in the opposite direction, and propose an altcoin that has
a \emph{malicious} proof-of-work that is externally detrimental.

In particular, we propose a proof-of-work that allows miners to prove they have
participated in a distributed denial of service (DDoS) attack against a
particular target. Miners are incentivized to send and receive large amounts of network
traffic at the target in order to produce a valid proof-of-work. As in other
cryptocurrencies, these proofs can be inexpensively verified by others, and the
original miner can collect a reward. This reward can be sold for other
currencies (including Bitcoin or even traditional currencies), allowing botnet
owners and other attacks to directly collect revenue for their assistance
in a decentralized DDoS attack.


The malicious proof-of-work operates by having miners create a large number of
TLS connections to a target webserver, and using the server's signed responses
as a proof of connection. In modern versions of TLS, the server signs a
client-provided parameter of the connection, along with server-provided values
used in the key exchange of the connection. This allows the client to prove to
others that it has communicated with the server. In addition, the signed value
returned by the server is not predictable to the client, and is randomly
distributed. Thus, clients can use a similar trick as in Bitcoin, and only
report connections that match some rare threshold, such as the signature from
the server starts with $N$ bits of 0s. On average, it will take clients $2^{N}$
connections to produce such a proof.

Although the malicious proof-of-work only works against websites that support
TLS 1.2, as of April 2016, over 56\% of the Alexa top million websites support
this version of TLS~\cite{censys}. Furthermore, we expect this number to
increase as TLS support becomes more widespread~\cite{letsencrypt}.

\emph{Contributions}
\begin{itemize}
\item Propose a novel conceptual cryptocurrency, DDoSCoin, whose proof-of-work
incentives miners to participate in a DDoS attack, and prove they have done so.
\item Implement our proof-of-work function and evaluate its performance.
\item Discuss and estimate the impact such a cryptocurrency would have if
deployed, and outline defenses.
\end{itemize}

Section blah does blah, and Section blat describes blat.





\section{Related Work}

Ethereum
Permacoin
Primecoin
Other interesting proofs-of-work?

Botnet-as-a-service

\section{Background}

\section{DDoSCoin Design}

Miners in DDoSCoin repeatedly create connections to a TLS victim server, and
check for a response that satisifes a target difficulty decided by the network.
If the response satisifies this condition, then parameters of the TLS handshake
can be published by the miner to create a new valid block.

To begin, a miner generates a random 32-byte secret nonce, $N$. The miner also
selects the latest block in the chain it is mining on, and the set of
transactions that the miner intends to include in this block, both as is done in
Bitcoin. The miner then takes the SHA256 hash of the previous block header, the
Merkle root of transactions (as generated in Bitcoin), and the secret nonce $N$,
and hashes their concatenation using SHA256 to generate the
32-byte \texttt{client\_random} the miner will use.

The miner initiates a TLSv1.2 connection with the victim server, using the
\texttt{client\_random}, and choosing a set of cipher suites that will ensure
the server will send a server key exchange message. This includes ephemeral
Diffie-Hellman (DHE), and ephemeral elliptic curve Diffie-Hellman (ECDHE). We
note that for the default cipher suite list sent by Google Chrome, over 94\%
of TLS 1.2 servers in the Alexa top million choose a cipher suite with a server key exchange
message~\cite{censys}, compatible with DDoSCoin.
% https://censys.io/domain/report?q=443.https.tls.version%3A%22TLSv1.2%22&field=443.https.tls.cipher_suite.name&max_buckets=


The server will respond with a server hello message, containing a 32-byte
\texttt{server\_random}, the cipher suite that will be used, and other
parameters that are not needed for the purposes of DDoSCoin.

Next, the server sends its certificate chain, and a server key exchange message.
The certificate chain contains the server's (signed) TLS certificate, as well as
intermediate certificate authorities (CAs) that create a signature chain to a
browser-trusted root CA. Inside the server's certificate is a public
key, as well as the identity of the server (i.e. it's domain). The miner stores
these for verification in case a block is found.

In the server key exchange message, the server sends key exchange parameters
(such as the Diffie-Hellman parameters and the ephemeral public value generated
by the server, or the curve parameters and a public curve point in ECDHE). These
key exchange parameters, along with the \texttt{client\_random} and
\texttt{server\_random},  are signed by the server using its private key; this
signature can be verified by using the public key in the certificate.

Because the server key exchange signature contains the \texttt{client\_random}
and \texttt{server\_random}, the signature value will be unpredictable to the
client ahead of time. In other words, each signature will be a random value that
depends on miner-provided value. Thus, it can be used as a proof-of-work in the
following way:

If the SHA256 hash of the server key exchange parameters, signature, and
miner-chosen nonce $N$ is less than the current target difficulty, then this
connection satisfies the proof-of-work threshold, and can be used to form the
next block.

To make a block, the miner publishes the prevoius block's hash, the transactions
(and their Merkle root), the nonce $N$, the \texttt{server\_random} value, the
server's certificate chain, the server key exchange parameters, and the server
key exchange signature.

\subsection{Validating Blocks}

To verify that a block is valid, miners must validate several items. First, they
must validate that the previous block hash and Merkle roots are valid, as in
Bitcoin. Next, they must re-create the \texttt{client\_random}, by hashing the
previous block hash, transaction Merkle root, and provided nonce. Then, they
must validate the certificate actually belongs to a valid victim server. This is
done by checking that the certificate chain is valid, rooted in a trusted
certificate authority, and the domain name is in a list of acceptable victims.
This list of valid victim domains is generated by concensus, and details for its
generation are discussed in Section~\ref{sec:victim}.

After the victim has been verified to be a valid one, the public key is used to
verify the server key exchange signature. This signature is over the
\texttt{client\_random}, \texttt{server\_random}, and server key exchange
parameters.

Finally, the block must be verified to meet the current target difficulty. The
server key exchange parameters, signature, and the block's nonce ($N$) are
hashed using SHA256, and compared to the current target difficulty. If it is
less than the target, the block is a valid one and becomes the latest block in
this chain.

\subsection{Earlier TLS Versions}

DDoSCoin is incompatible with earlier TLS (or even SSL) versions because the
server key exchange signature does not include the \texttt{client\_random}, or
any client-provided values. If we were to try to base a proof-of-work off of an
earlier version of TLS, the only value that provably comes from the server (i.e.
is signed by a key tied to the victim's identity) does not contain any
comittments from the client about the previous block, or what transactions
should be included in the block. If we were to accept blocks where there was
only a server signature that met some target difficulty, any miner could steal
another miner's found block (and the contained block reward) by changing the
transactions and forwarding the block.

If we were to somehow tie the previous block's hash and Merkle root into this
proof, for example, by saying that the hash of the signature and a
client-provided nonce had to be less than some target value, the proof-of-work becomes
a computational puzzle: a miner only has to collect a single signature from
the server, and try different nonces until the hash of signature and nonce meets
the target difficulty.

Similarly, proof-of-work target difficulties can not be based off of the
purported shared secret that results from a connection, because the client can
always choose different key exchange values to ensure that the resulting shared
secret is less than than the threshold difficulty, resulting in a computational
puzzle. Even values sent by the server---such as the Finished message that
contains a MAC dependent on the shared secret---can be (re)computed by the client.

This interesting property gives rise to an observation that with respect to
clients, the contents of TLS connections are \emph{deniable}. That is, it is not
possible for a client to record a TLS connection, including its chosen secrets,
and report this to a third party in a way that cryptographically proves what the
server says. This property has been accomplished in different more efficient ways in various
secure messaging protocols such as Off-the-Record (OTR)~\cite{otr}.

Besides TLS 1.2, there are other cryptographic protocols that have the feature
of the server signing a client-chosen value. For example, SSH ... \TK

Although not yet implemented, the TLS 1.3 proposal appears to also have ... \TK




\subsection{Victim Selection}
\label{sec:victim}

If DDoSCoin accepted proofs against any TLS 1.2 server, miners would be
incentivized to solve local challenges rather than remote ones, leading to the
proof-of-work being a computational puzzle, rather than one based on
participation in a network denial of service. Thus, DDoSCoin must have a way to
agree on what victims are acceptable targets for the proofs-of-work to be considered
valid.

One simple way is to hardcode a set of victim certificates into the protocol.
For example, DDoSCoin's published code could contain the identities of
Facebook's servers, and only incentivize attacks against them. However, there
are many attackers that might feel uncomfortable attacking Facebook, but would
be willing to participate in attacks against other websites. In addition, having
only a single or small set of websites is a risk to DDoSCoin: if those websites
all go offline or successfully mitigate the attacks (such as by disabling TLS),
no future DDoSCoin blocks can be mined, and the currency will stall. At this
point, all DDoSCoins in circulation would become nearly worthless, as there
would be no way to safely transact them.

These issues lead to a few subtle requirements for choosing valid victims.
First, there must be \emph{limits} on who is allowed to be a victim, otherwise
miners can create local computational puzzles. At the same time, there must be
\emph{enough} targets in order to be robust. Similarly, the list of victims must
be \emph{flexible} in order to prevent a stalled blockchain through downed or
propery defended servers.

To address these issues, we propose two mechanisms the DDoSCoin protocol can
employ.


\subsubsection{Pay-to-DDoS}

In order to allow the set of victims to be updated, DDoSCoin could allow payment
for targetting specific servers. To accomplish this, DDoSCoin introduces a new
payment opcode, PAY\_TO\_DDOS, that can be used in transactions subject to
certain constraints. This opcode takes one argument: a string representing a
domain name that the payer wishes to add to the set of victim servers. The
transaction has no other parameters, but its value must be greater than the
coinbase reward a miner would normally receive, and it must carry a
non-negligble transaction fee. Once this transaction is stored in a valid block,
the specified domain name is temporarily added to the list of allowed victims.
The first miner to mine a block with that domain as the victim must specify the
PAY\_TO\_DDOS transaction as an input to its coinbase transaction (with any
arbitrary output address), and have no other coinbase transactions. In other
words, the miner collects the value in the PAY\_TO\_DDOS transaction in lieu of
the normal block reward.

The observant reader will notice that nothing stops the payer of the
PAY\_TO\_DDOS transaction and the miner that it goes to from being the same
entity. Indeed, a miner could create a PAY\_TO\_DDOS transaction with a victim
domain that only it has access to, ensuring that it will be able to mine the
block without competition, and collect its own payment. However, this will not
net the miner new coins (\TK beyond any transaction fees collected? But we could
make this block contain no transactions), as the coinbase transaction is
replaced with its own PAY\_TO\_DDOS input. 


\subsubsection{Alternate Proof-of-Work}






-However, the victim could easily generate a new certificate; should instead
base identity off domain rooted to valid root CAs.


DDoSCoin must select a small set of victim servers to p


-Miners vote (proof-of-stake-esq)




\section{Discussion}

-Proof of (burnt) bandwidth
-Defenses
-Target server's participation

\subsection{Ethical Considerations}
%¯\\\_(ツ)\_/¯
%\symbol{2544}
\shrug

% ¯\_(ツ)_/¯

\section{Conclusion}



{\footnotesize\balance
\bibliographystyle{plain}
\bibliography{paper}}

\end{document}
